================================================================================
カトル (Cuttle) ゲームシステム設計書 - 完全版
================================================================================
バージョン: 1.0
最終更新: 2026/01/08
================================================================================

【目次】
1. ゲーム概要
2. データ構造
3. ゲームルール
4. カード効果詳細
5. 種族相性システム
6. UI/UX仕様
7. 状態管理フロー
8. CPU AI ロジック
9. スプライト/ビジュアル仕様
10. ファイル構成

================================================================================
1. ゲーム概要
================================================================================

■ ゲームタイトル: カトル (Cuttle)
■ ジャンル: 2人対戦カードゲーム（TCG風）
■ テーマ: ダークファンタジー（中世ヨーロッパ/冒険者ギルド）
■ プラットフォーム: Web（React + TypeScript + Vite）

■ 勝利条件:
  - 場に出した点数カードの合計が目標点数に達する
  - 目標点数は王(K)の枚数で変動:
    - 王0枚: 21点
    - 王1枚: 14点
    - 王2枚: 10点
    - 王3枚: 7点
    - 王4枚: 5点

■ 引き分け条件:
  - 山札が0枚の状態で3回連続パスが発生

================================================================================
2. データ構造
================================================================================

【2.1 種族 (Race)】
type Race = 'elf' | 'goblin' | 'human' | 'demon';

- elf (エルフ): 色=黄色系 (--race-elf: #a89f40)
- goblin (ゴブリン): 色=緑系 (--race-goblin: #3d7a47)
- human (人間/ニンゲン): 色=赤系 (--race-human: #8b3a3a)
- demon (デーモン/悪魔): 色=青系 (--race-demon: #3a4d8b)

【2.2 ランク (Rank)】
type Rank = 'A' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | 'J' | 'Q' | 'K';

【2.3 カード (Card)】
interface Card {
  id: string;        // 一意識別子 (例: "elf-A", "demon-10")
  rank: Rank;        // ランク
  race: Race;        // 種族
  value: number;     // 点数値
}

- 点数計算:
  - A = 1点
  - 2～10 = 数字通りの点数
  - J, Q, K = 0点（点数カードにならない）
  - 8を永続効果として出した場合 = 0点（value=0に変更される）

【2.4 場のカード (FieldCard)】
interface FieldCard {
  card: Card;                              // カード本体
  attachedKnights: Card[];                 // 付いている騎士(J)の配列
  owner: 'player1' | 'player2';            // 元の所有者
  controller: 'player1' | 'player2';       // 現在の支配者
}

- owner: カードを最初に場に出したプレイヤー
- controller: 現在そのカードの点数を得ているプレイヤー
  - Jで略奪されると controller が変わる
  - attachedKnights の最新のJの持ち主が controller

【2.5 プレイヤー (Player)】
interface Player {
  id: 'player1' | 'player2';
  name: string;          // 表示名
  hand: Card[];          // 手札
  field: FieldCard[];    // 場に出ているカード
  kings: number;         // 場に出ている王の数（勝利点数計算用）
}

【2.6 ゲーム状態 (GameState)】
interface GameState {
  deck: Card[];                      // 山札
  scrapPile: Card[];                 // 捨て札（墓地）
  player1: Player;                   // プレイヤー1（人間）
  player2: Player;                   // プレイヤー2（CPU）
  currentPlayer: 'player1' | 'player2';
  phase: GamePhase;                  // 現在のフェーズ
  winner: 'player1' | 'player2' | null;
  turnCount: number;                 // ターン数
  consecutivePasses: number;         // 連続パス回数
  selectedCard: Card | null;         // 選択中のカード
  selectedAction: ActionType | null; // 選択中のアクション
  targetCard: FieldCard | null;      // ターゲット
  message: string;                   // UI表示メッセージ
  opponentHandRevealed: {            // 8の効果で手札公開中か
    player1: boolean;
    player2: boolean;
  };
  sevenChoices?: Card[];             // 7の効果で選択する山札トップ2枚
}

【2.7 ゲームフェーズ (GamePhase)】
type GamePhase = 
  | 'waiting'         // ゲーム開始待ち
  | 'selectAction'    // アクション選択中
  | 'selectTarget'    // ターゲット選択中
  | 'opponentDiscard' // 4の効果で手札を捨てる
  | 'sevenChoice'     // 7の効果でカード選択
  | 'gameOver';       // ゲーム終了

【2.8 アクションタイプ (ActionType)】
type ActionType = 
  | 'draw'            // ドロー
  | 'playPoint'       // 点数カードとして配置
  | 'playOneOff'      // ワンオフ効果発動
  | 'playPermanent'   // 永続効果配置
  | 'playKnight'      // 騎士で略奪
  | 'scuttle'         // アタック（スカトル）
  | 'pass';           // パス

================================================================================
3. ゲームルール
================================================================================

【3.1 デッキ構成】
- 4種族 × 13ランク = 52枚

【3.2 ゲーム開始】
1. デッキをシャッフル
2. 先攻（player1）に5枚配布
3. 後攻（player2）に6枚配布
4. player1のターンから開始

【3.3 ターンの流れ】
各ターン、プレイヤーは以下のいずれか1つを実行:

A) ドロー
   - 山札から1枚引いて手札に加える
   - 山札が0枚の時は実行不可

B) パス
   - 何もせずターンを終了
   - 山札が0枚の時のみ実行可能
   - 3回連続パスで引き分け

C) カードをプレイ
   - 点数カードとして出す（点数エリアへ）
   - ワンオフ効果を発動（効果エリアへドロップ→捨て札へ）
   - 永続効果として配置（効果エリアへ）
   - アタック（相手の点数カードを破壊）

【3.4 点数計算】
- 自分がコントロール(controller)している点数カードの value を合計
- Jで略奪したカードは、元の場所に関係なく略奪者の点数になる
- 8を永続効果として出した場合は value=0 なのでカウントされない

【3.5 勝利判定】
- ターン終了時に点数計算
- 目標点数（Kの枚数で変動）以上で勝利

================================================================================
4. カード効果詳細
================================================================================

【4.1 数字カード (A, 2-10) の点数】
- A = 1点
- 2～10 = 数字通りの点数

【4.2 ワンオフ効果（使用後すぐ捨て札）】

■ A (エース)
  - 効果: 相手の点数カード1枚を破壊
  - ターゲット: 相手の点数エリアのカード（value > 0）
  - 制限: 相手が魔術師(Q)を持っている場合は無効

■ 2
  - 効果: 相手の永続効果カード1枚を破壊
  - ターゲット: J, Q, K, または value=0 の8
  - Kを破壊した場合: 相手の kings カウントを-1

■ 3
  - 効果: 捨て札から1枚を手札に回収
  - ターゲット: 墓地のカード
  - UI: 墓地モーダルから選択

■ 4
  - 効果: 相手は手札を2枚捨てる
  - 処理: phase を 'opponentDiscard' に変更
  - CPU: 低価値カードから自動選択
  - プレイヤー: 手動で2枚選択

■ 5
  - 効果: 山札から2枚ドロー
  - 即時効果（ターゲット不要）

■ 6
  - 効果: 全ての永続効果カードを破壊（自分含む）
  - 対象: 両プレイヤーの J, Q, K, value=0の8
  - 処理:
    - 全永続カードを捨て札へ
    - Kは kings カウントを減算
    - Jが破壊されたら、対象カードの controller を owner に戻す

■ 7
  - 効果: 山札の上2枚を見て、1枚を選んでプレイ
  - 処理:
    - phase を 'sevenChoice' に変更
    - sevenChoices に山札トップ2枚をセット
    - プレイヤーが選択 → 手札に加えてプレイ

■ 9
  - 効果: 相手のカード1枚を手札に戻す
  - ターゲット: 点数カード or 永続効果カード
  - 点数カード: 魔術師保護下なら無効
  - Kを戻した場合: kings カウントを-1
  - Jを戻した場合: 対象カードの attachedKnights から除去、controller を再計算

■ 10
  - 効果: 相手の点数カード1枚を手札に戻す
  - ターゲット: value > 0 のカードのみ
  - 制限: 魔術師保護下なら無効

【4.3 永続効果（場に残る）】

■ 8 (密偵)
  - 2つの使い方:
    A) 点数カードとして出す → value=8 のまま（点数エリアへ）
    B) 永続効果として出す → value=0 に変更（効果エリアへ）
  - 永続効果: 相手の手札を常に見える状態にする
  - opponentHandRevealed[相手ID] = true
  - 破壊されたら false に戻す（未実装）

■ J (騎士)
  - 効果: 相手がコントロールしている点数カードを略奪
  - ターゲット:
    - controller が相手のカード
    - value > 0 のカードのみ
  - 処理:
    - targetField.attachedKnights に J を追加
    - targetField.controller を自分に変更
  - 特殊: 同じカードに複数のJを付けられる（最新Jの持ち主が支配）
  - カウンター略奪: 相手にJされたカードに自分のJを使うと取り戻せる

■ Q (魔術師)
  - 効果: 自分の点数カードを効果から保護
  - 保護対象: A, 10, J の効果を無効化
  - hasQueen(player) でチェック

■ K (王)
  - 効果: 勝利に必要な点数を下げる
  - 処理: player.kings++ 
  - 勝利点数: WINNING_POINTS[kings] を参照

【4.4 アタック（スカトル）】
- 自分の点数カード（手札から）で相手の点数カードを攻撃
- 条件:
  - 攻撃側の value >= 防御側の value
  - 同数の場合: 種族相性で可否判定
- 結果: 常に相打ち（両方捨て札）
- 魔術師保護下のカードには攻撃不可

================================================================================
5. 種族相性システム
================================================================================

【5.1 強さ順位】
エルフ(0) < ゴブリン(1) < 人間(2) < デーモン(3)

【5.2 特殊ルール】
- エルフはデーモンにのみ勝てる
- デーモンはエルフに負ける

【5.3 相性判定関数】
getRaceMatchup(attacker, defender) → 'win' | 'lose' | 'draw'

【5.4 同数値アタックのルール】
- 有利な種族 → アタック可能（相打ち）
- 不利な種族 → アタック不可
- 同じ種族 → アタック可能（相打ち）

================================================================================
6. UI/UX仕様
================================================================================

【6.1 画面構成（上から下）】

1. 敵情報バー (cuttle-enemy-info)
   - 右寄せ: アイコン | 名前 | 点数pt/目標点

2. 敵手札エリア (cuttle-enemy-hand)
   - カード裏面を扇状に表示（逆向き）
   - 8永続効果発動時は表面表示 + 👁マーク

3. 敵効果エリア (cuttle-enemy-effects)
   - 永続効果カード表示

4. 敵点数エリア (cuttle-enemy-points-area)
   - 点数カード表示（ドロップターゲット）

5. 山札・ログ・墓地エリア (cuttle-deck-area)
   - 山札: 枚数に応じた重なり表現
   - ログ: 最新アクションを下部に表示（スクロール可能）
   - 墓地: 枚数に応じた重なり表現（クリックでモーダル）

6. 自分点数エリア (cuttle-player-points-area)
   - 点数カード表示（ドロップターゲット）

7. 自分効果エリア (cuttle-player-effects)
   - 永続効果カード表示（ドロップターゲット）

8. ステータスバー (cuttle-status-bar)
   - 左寄せ: アイコン | 名前 | 点数pt/目標点
   - ボタン: ドロー | パス | ✕

9. 自分手札エリア (cuttle-hand)
   - カードを扇状に表示

【6.2 UIモード】
type Mode = 'default' | 'browsing' | 'dragging';

■ default: 通常状態
■ browsing: カードタップ時の閲覧モード
  - オーバーレイ表示
  - カードを拡大表示
  - 手札を下部に扇状表示
  - 横スワイプでカード切り替え
■ dragging: カードドラッグ中
  - 上に50px以上移動で移行
  - ドロップターゲットをハイライト

【6.3 タッチ操作】
- タップ: 閲覧モード開始
- 上方向ドラッグ: ドラッグモード開始
- 横方向スワイプ: カード選択切り替え
- ドロップ: カードをプレイ/効果発動

【6.4 ドロップターゲット】
- playerPoints: 点数として出す
- playerEffects: 効果として出す/永続配置
- enemyPoints: アタック or 効果ターゲット
- enemyEffects: 2の効果ターゲット
- enemyCard:N: 個別カードターゲット
- playerCard:N: 自分のカードへのJカウンター

【6.5 アクション確認モーダル】
- 敵カードへドロップ時に表示
- 選択肢:
  - J: 「略奪する」
  - A/2: 「効果で破壊」
  - 9/10: 「手札に戻す」
  - 点数カード: 「アタック」（条件を満たす場合）
  - 「戻る」

【6.6 ログシステム】
- LogEntry: { id, player, message }
- プレイヤー1: 水色 (#5ed3f3)
- プレイヤー2: 赤色 (#f35e5e)
- 最新が下部に追加
- 自動スクロール

【6.7 カード重なり表現】
getStackCount(count):
- 1枚: 1
- 2-5枚: そのまま
- 6-10枚: 6
- 11-15枚: 7
- 16-20枚: 8
- 21-25枚: 9
- 26-30枚: 10
- 31-35枚: 11
- 36枚以上: 12

================================================================================
7. 状態管理フロー
================================================================================

【7.1 メインステートフロー (App.tsx)】

A) ドロー処理:
   handleAction('draw') → drawCard(gameState) → endTurn()

B) パス処理:
   handleAction('pass') → pass(gameState) → endTurn()
   ※ 山札0枚時のみ可能

C) 点数カード配置:
   1. CuttleBattle: onCardSelect(card)
   2. CuttleBattle: onAction('playPoint')
   3. App: playAsPoint(gameState, selectedCard)
   4. playCardToField(state, player, card, false)
   5. checkWinCondition() → endTurn()

D) 永続効果配置 (Q, K, 8):
   1. CuttleBattle: onCardSelect(card)
   2. CuttleBattle: onAction('playPermanent')
   3. App: playAsPermanent(gameState, selectedCard)
   4. playCardToField(state, player, card, true)
   5. 8の場合: value=0に変更、opponentHandRevealed=true
   6. Kの場合: player.kings++
   7. endTurn()

E) Jで略奪:
   1. CuttleBattle: pendingCard, pendingTarget を設定
   2. モーダルで「略奪する」選択
   3. onDirectAction('playKnight', card, target)
   4. App: playKnight(gameState, card, target)
   5. target.attachedKnights.push(card)
   6. target.controller = 自分
   7. endTurn()

F) ワンオフ効果:
   1. CuttleBattle: onCardSelect(card)
   2. ターゲット必要な場合: onDirectAction('playOneOff', card, target)
   3. ターゲット不要な場合: onAction('playOneOff')
   4. App: executeOneOff(gameState, card, target)
   5. カード効果実行
   6. card を捨て札へ
   7. endTurn()

G) アタック:
   1. CuttleBattle: pendingCard, pendingTarget を設定
   2. モーダルで「アタック」選択
   3. onDirectAction('scuttle', card, target)
   4. App: executeScuttle(gameState, card, target)
   5. canScuttle() でチェック
   6. 両カードを捨て札へ
   7. endTurn()

【7.2 ターン終了処理 (endTurn)】
1. currentPlayer を切り替え
2. turnCount++
3. phase = 'selectAction'
4. selectedCard, selectedAction, targetCard をクリア
5. checkWinCondition()
6. 勝者がいれば phase = 'gameOver'

【7.3 CPUターン処理】
- useEffect で currentPlayer === 'player2' を監視
- 800-1500ms のランダム遅延後に getCPUAction() を実行
- アクション結果で状態更新

================================================================================
8. CPU AI ロジック
================================================================================

【8.1 優先順位（getCPUAction）】

1. 勝てるなら点数カードを出す
   - cpuPoints + card.value >= cpuTarget なら playPoint

2. 相手が勝ちそうなら妨害
   - playerPoints >= playerTarget - 5 の場合:
   - Aで高得点カードを破壊（魔術師なし時）
   - アタックで妨害

3. 王を出す（2枚まで）
   - playPermanent(K)

4. 魔術師を出す（1枚まで、点数カードがある場合）
   - playPermanent(Q)

5. 相手の永続カードを2で破壊
   - Q, K, 8永続 を優先

6. 7点以上の点数カードを出す
   - playPoint

7. 5で2枚ドロー（山札2枚以上）
   - playOneOff(5)

8. Jで相手のカードを奪う（魔術師なし時）
   - 高得点カードを優先

9. 8を永続効果として出す（未公開時）
   - playPermanent(8)

10. 4点以上の点数カードを出す
    - playPoint

11. ドローする（山札あり）
    - draw

12. 残りの点数カードを出す
    - playPoint

13. パス

【8.2 CPUの手札捨て（4の効果）】
- 低価値カードから優先的に捨てる
- value=0 のカード（J,Q,K） > 低い点数カード

================================================================================
9. スプライト/ビジュアル仕様
================================================================================

【9.1 スプライトフォルダ構成】
public/sprite/
├── suit/
│   ├── elf.png      (エルフアイコン)
│   ├── goblin.png   (ゴブリンアイコン)
│   ├── human.png    (人間アイコン)
│   └── demon.png    (デーモンアイコン)
├── ajqk/
│   ├── ea.png       (エルフA)
│   ├── ej.png       (エルフJ)
│   ├── eq.png       (エルフQ)
│   ├── ek.png       (エルフK)
│   ├── ga.png       (ゴブリンA)
│   ├── gj.png       (ゴブリンJ)
│   ├── gq.png       (ゴブリンQ)
│   ├── gk.png       (ゴブリンK)
│   ├── ha.png       (人間A)
│   ├── hj.png       (人間J)
│   ├── hq.png       (人間Q)
│   ├── hk.png       (人間K)
│   ├── da.png       (デーモンA)
│   ├── dj.png       (デーモンJ)
│   ├── dq.png       (デーモンQ)
│   └── dk.png       (デーモンK)
└── back/
    └── backmain.png (カード裏面中央イラスト)

【9.2 種族コード】
RACE_CODES: {
  elf: 'e', Elf: 'e',
  goblin: 'g', Goblin: 'g',
  human: 'h', Human: 'h',
  demon: 'd', Demon: 'd'
}

【9.3 スプライトパス生成】
- スートアイコン: ${BASE_URL}sprite/suit/${race.toLowerCase()}.png
- 絵札イラスト: ${BASE_URL}sprite/ajqk/${raceCode}${rank.toLowerCase()}.png

【9.4 スプライト着色（CSS mask-image）】
- スプライトは白色+透明背景
- CSS mask-image で形状を定義
- background-color で着色
- WebkitMaskImage も必要（Safari対応）

【9.5 種族別カラー（CSS変数）】
--race-human: #8b3a3a (暗い赤)
--race-demon: #3a4d8b (暗い青)
--race-elf: #a89f40 (くすんだ黄)
--race-goblin: #3d7a47 (暗い緑)

【9.6 カードデザイン】

■ カード表面:
  - アスペクト比: 5:7 (横:縦)
  - 背景: card-parchment（焦げた羊皮紙風グラデーション）
  - 絵札(A,J,Q,K): card-face-art で中央にイラスト
  - 数字カード(2-10): card-pips でトランプ風配置
  - ランク表示: 左上と右下（反転）

■ カード裏面:
  - card-back-parchment: 羊皮紙背景
  - card-back-main: 中央にbackmain.png
  - card-back-suit: 四隅にスートアイコン（向かい合わせ）
  - card-back-frame: 装飾フレーム

■ 数字カードのpip配置 (PIP_LAYOUTS):
  2: 上中央、下中央(反転)
  3: 上中央、中央、下中央(反転)
  4: 左上、右上、左下(反転)、右下(反転)
  5: 4 + 中央
  6: 左上、右上、左中央、右中央、左下(反転)、右下(反転)
  7: 6 + 上中央寄り
  8: 7 + 下中央寄り(反転)
  9: 4角 + 中段2つ + 中央 (4-4-1配置)
  10: 4角 + 中段 + 追加2つ (4-2-2-2配置)

【9.7 場のカード】
- フルサイズ表示（エリア高さの95%）
- card-parchment背景
- 絵札/pipレイアウト表示
- 下部に情報ボックス（カード外）
  - スートアイコン + ランク

【9.8 J略奪オーバーレイ】
- stolen-overlay クラス
- player-control: 金色オーバーレイ + 'J'マーク
- enemy-control: 赤色オーバーレイ + 'J'マーク

【9.9 フィールド背景色】
- プレイヤーエリア: 青系グラデーション
- 敵エリア: 赤系グラデーション

================================================================================
10. ファイル構成
================================================================================

cuttle-game/
├── index.html              # エントリポイント（フォント読み込み）
├── package.json            # 依存関係
├── vite.config.ts          # Vite設定（base: '/cuttle-game/'）
├── tsconfig.json           # TypeScript設定
├── public/
│   └── sprite/             # スプライト画像
├── src/
│   ├── main.tsx            # Reactエントリポイント
│   ├── App.tsx             # メインアプリ（状態管理）
│   ├── types/
│   │   └── game.ts         # 型定義
│   ├── utils/
│   │   ├── gameLogic.ts    # ゲームロジック
│   │   ├── cardActions.ts  # カードアクション
│   │   └── cpuAI.ts        # CPU AI
│   └── components/
│       ├── CuttleBattle.tsx  # バトル画面UI
│       └── CuttleBattle.css  # スタイル

================================================================================
【補足】重要な実装ポイント
================================================================================

1. カード選択の同期
   - ドラッグ後にonAction()を呼ぶ前に必ずonCardSelect(card)を呼ぶ
   - これがないとgameState.selectedCardが古いままになる

2. 点数計算のcontroller考慮
   - player.field だけでなく enemy.field もチェック
   - fc.controller === playerId のカードをカウント

3. 8カードの二面性
   - 点数として出す: value=8維持
   - 永続として出す: value=0に変更
   - フィルタリング時にisFieldPermanent()で判定

4. Jの重ね掛け
   - attachedKnights配列で管理
   - 最新のJの持ち主がcontroller

5. BASE_URL
   - GitHub Pages対応
   - import.meta.env.BASE_URL で取得
   - スプライトパス生成時に使用

================================================================================
以上
================================================================================

